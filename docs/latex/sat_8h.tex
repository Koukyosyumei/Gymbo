\hypertarget{sat_8h}{}\doxysection{libgymbo/sat.h File Reference}
\label{sat_8h}\index{libgymbo/sat.h@{libgymbo/sat.h}}


Implementation of SAT solver.  


{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$memory$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$unordered\+\_\+map$>$}\newline
{\ttfamily \#include $<$unordered\+\_\+set$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include \char`\"{}type.\+h\char`\"{}}\newline
Include dependency graph for sat.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{sat_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=199pt]{sat_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classgymbosat_1_1Expr}{gymbosat\+::\+Expr}}
\begin{DoxyCompactList}\small\item\em Base class for representing logical expressions. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgymbosat_1_1Var}{gymbosat\+::\+Var}}
\begin{DoxyCompactList}\small\item\em Class representing a variable in a logical expression. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgymbosat_1_1And}{gymbosat\+::\+And}}
\begin{DoxyCompactList}\small\item\em Class representing the logical AND operation. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgymbosat_1_1Or}{gymbosat\+::\+Or}}
\begin{DoxyCompactList}\small\item\em Class representing the logical OR operation. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgymbosat_1_1Not}{gymbosat\+::\+Not}}
\begin{DoxyCompactList}\small\item\em Class representing the logical NOT operation. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgymbosat_1_1Const}{gymbosat\+::\+Const}}
\begin{DoxyCompactList}\small\item\em Class representing a boolean constant in a logical expression. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{sat_8h_a6d86d55f55f58425a61afe7f71066024}\label{sat_8h_a6d86d55f55f58425a61afe7f71066024}} 
enum \mbox{\hyperlink{sat_8h_a6d86d55f55f58425a61afe7f71066024}{gymbosat\+::\+Op\+Code}} \{ \newline
{\bfseries VAR}
, {\bfseries AND}
, {\bfseries OR}
, {\bfseries NOT}
, \newline
{\bfseries CONST}
 \}
\begin{DoxyCompactList}\small\item\em Enum representing different logical operation codes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{sat_8h_ab93a240afc8d89ec25d1bb528545f6d2}\label{sat_8h_ab93a240afc8d89ec25d1bb528545f6d2}} 
enum \mbox{\hyperlink{sat_8h_ab93a240afc8d89ec25d1bb528545f6d2}{gymbosat\+::\+Polarity}} \{ {\bfseries Positive}
, {\bfseries Negative}
, {\bfseries Mixed}
 \}
\begin{DoxyCompactList}\small\item\em Enum representing different polarities in logical expressions. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::shared\+\_\+ptr$<$ Expr $>$ \mbox{\hyperlink{sat_8h_aee3ea3ef6116322c249d4f557b51326d}{gymbosat\+::cnf}} (std\+::shared\+\_\+ptr$<$ Expr $>$ expr)
\begin{DoxyCompactList}\small\item\em Convert a logical expression to conjunctive normal form (CNF). \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ Expr $>$ \mbox{\hyperlink{sat_8h_a39eb2e94bf479cf70e9f4f20ae1b7ed4}{gymbosat\+::literal\+Elimination}} (std\+::shared\+\_\+ptr$<$ Expr $>$ expr, std\+::unordered\+\_\+map$<$ std\+::string, bool $>$ \&assignments\+\_\+map)
\begin{DoxyCompactList}\small\item\em Eliminate literals in a logical expression based on assignments. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::pair$<$ std\+::string, bool $>$ $>$ \mbox{\hyperlink{sat_8h_a53351856c441258f036913048a7777c4}{gymbosat\+::all\+Unit\+Clauses}} (std\+::shared\+\_\+ptr$<$ Expr $>$ expr)
\begin{DoxyCompactList}\small\item\em Extract all unit clauses from a logical expression. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ Expr $>$ \mbox{\hyperlink{sat_8h_a900a3e916b5f594baf9598112ff29db9}{gymbosat\+::unit\+Propagation}} (std\+::shared\+\_\+ptr$<$ Expr $>$ expr, std\+::unordered\+\_\+map$<$ std\+::string, bool $>$ \&assignments\+\_\+map)
\begin{DoxyCompactList}\small\item\em Perform unit propagation on a logical expression based on assignments. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{sat_8h_a1b9fe029a32c35b69482f3d410b5e649}{gymbosat\+::satisfiable\+DPLL}} (std\+::shared\+\_\+ptr$<$ Expr $>$ expr, std\+::unordered\+\_\+map$<$ std\+::string, bool $>$ \&assignments\+\_\+map)
\begin{DoxyCompactList}\small\item\em Check satisfiability of a logical expression using the DPLL algorithm. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ Expr $>$ \mbox{\hyperlink{sat_8h_a03e10dde5ead3c1638a3959f61df655a}{gymbosat\+::sym2expr}} (\mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $\ast$sym, std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $\ast$ $>$ \&unique\+\_\+sym\+\_\+map)
\begin{DoxyCompactList}\small\item\em Convert a symbolic expression to a logical expression. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ Expr $>$ \mbox{\hyperlink{sat_8h_a6f0b9965254e8e0a97d6ce893d01cd06}{gymbosat\+::pathconstraints2expr}} (std\+::vector$<$ \mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $>$ \&constraints, std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $\ast$ $>$ \&unique\+\_\+sym\+\_\+map)
\begin{DoxyCompactList}\small\item\em Convert a vector of symbolic path constraints to a logical expression. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Implementation of SAT solver. 

\begin{DoxyAuthor}{Author}
Hideaki Takahashi 
\end{DoxyAuthor}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{sat_8h_a53351856c441258f036913048a7777c4}\label{sat_8h_a53351856c441258f036913048a7777c4}} 
\index{sat.h@{sat.h}!allUnitClauses@{allUnitClauses}}
\index{allUnitClauses@{allUnitClauses}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{allUnitClauses()}{allUnitClauses()}}
{\footnotesize\ttfamily std\+::vector$<$std\+::pair$<$std\+::string, bool$>$ $>$ gymbosat\+::all\+Unit\+Clauses (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classgymbosat_1_1Expr}{Expr}} $>$}]{expr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Extract all unit clauses from a logical expression. 


\begin{DoxyParams}{Parameters}
{\em expr} & Shared pointer to the logical expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of pairs representing unit clauses\+: (literal, value). 
\end{DoxyReturn}
\mbox{\Hypertarget{sat_8h_aee3ea3ef6116322c249d4f557b51326d}\label{sat_8h_aee3ea3ef6116322c249d4f557b51326d}} 
\index{sat.h@{sat.h}!cnf@{cnf}}
\index{cnf@{cnf}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{cnf()}{cnf()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$Expr$>$ gymbosat\+::cnf (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classgymbosat_1_1Expr}{Expr}} $>$}]{expr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert a logical expression to conjunctive normal form (CNF). 


\begin{DoxyParams}{Parameters}
{\em expr} & Shared pointer to the logical expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the expression in CNF. 
\end{DoxyReturn}
\mbox{\Hypertarget{sat_8h_a39eb2e94bf479cf70e9f4f20ae1b7ed4}\label{sat_8h_a39eb2e94bf479cf70e9f4f20ae1b7ed4}} 
\index{sat.h@{sat.h}!literalElimination@{literalElimination}}
\index{literalElimination@{literalElimination}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{literalElimination()}{literalElimination()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$Expr$>$ gymbosat\+::literal\+Elimination (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classgymbosat_1_1Expr}{Expr}} $>$}]{expr,  }\item[{std\+::unordered\+\_\+map$<$ std\+::string, bool $>$ \&}]{assignments\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Eliminate literals in a logical expression based on assignments. 


\begin{DoxyParams}{Parameters}
{\em expr} & Shared pointer to the logical expression. \\
\hline
{\em assignments\+\_\+map} & Reference to an unordered map of variable assignments. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the modified logical expression. 
\end{DoxyReturn}
\mbox{\Hypertarget{sat_8h_a6f0b9965254e8e0a97d6ce893d01cd06}\label{sat_8h_a6f0b9965254e8e0a97d6ce893d01cd06}} 
\index{sat.h@{sat.h}!pathconstraints2expr@{pathconstraints2expr}}
\index{pathconstraints2expr@{pathconstraints2expr}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{pathconstraints2expr()}{pathconstraints2expr()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$Expr$>$ gymbosat\+::pathconstraints2expr (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $>$ \&}]{constraints,  }\item[{std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $\ast$ $>$ \&}]{unique\+\_\+sym\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert a vector of symbolic path constraints to a logical expression. 


\begin{DoxyParams}{Parameters}
{\em constraints} & Vector of symbolic path constraints. \\
\hline
{\em unique\+\_\+sym\+\_\+map} & Reference to an unordered map of unique symbolic expressions. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the logical expression representing the path constraints. 
\end{DoxyReturn}
\mbox{\Hypertarget{sat_8h_a1b9fe029a32c35b69482f3d410b5e649}\label{sat_8h_a1b9fe029a32c35b69482f3d410b5e649}} 
\index{sat.h@{sat.h}!satisfiableDPLL@{satisfiableDPLL}}
\index{satisfiableDPLL@{satisfiableDPLL}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{satisfiableDPLL()}{satisfiableDPLL()}}
{\footnotesize\ttfamily bool gymbosat\+::satisfiable\+DPLL (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classgymbosat_1_1Expr}{Expr}} $>$}]{expr,  }\item[{std\+::unordered\+\_\+map$<$ std\+::string, bool $>$ \&}]{assignments\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Check satisfiability of a logical expression using the DPLL algorithm. 


\begin{DoxyParams}{Parameters}
{\em expr} & Shared pointer to the logical expression. \\
\hline
{\em assignments\+\_\+map} & Reference to an unordered map of variable assignments. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the expression is satisfiable, false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{sat_8h_a03e10dde5ead3c1638a3959f61df655a}\label{sat_8h_a03e10dde5ead3c1638a3959f61df655a}} 
\index{sat.h@{sat.h}!sym2expr@{sym2expr}}
\index{sym2expr@{sym2expr}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{sym2expr()}{sym2expr()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$Expr$>$ gymbosat\+::sym2expr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $\ast$}]{sym,  }\item[{std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{structgymbo_1_1Sym}{gymbo\+::\+Sym}} $\ast$ $>$ \&}]{unique\+\_\+sym\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Convert a symbolic expression to a logical expression. 


\begin{DoxyParams}{Parameters}
{\em sym} & Pointer to the symbolic expression. \\
\hline
{\em unique\+\_\+sym\+\_\+map} & Reference to an unordered map of unique symbolic expressions. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the corresponding logical expression. 
\end{DoxyReturn}
\mbox{\Hypertarget{sat_8h_a900a3e916b5f594baf9598112ff29db9}\label{sat_8h_a900a3e916b5f594baf9598112ff29db9}} 
\index{sat.h@{sat.h}!unitPropagation@{unitPropagation}}
\index{unitPropagation@{unitPropagation}!sat.h@{sat.h}}
\doxysubsubsection{\texorpdfstring{unitPropagation()}{unitPropagation()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$Expr$>$ gymbosat\+::unit\+Propagation (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classgymbosat_1_1Expr}{Expr}} $>$}]{expr,  }\item[{std\+::unordered\+\_\+map$<$ std\+::string, bool $>$ \&}]{assignments\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Perform unit propagation on a logical expression based on assignments. 


\begin{DoxyParams}{Parameters}
{\em expr} & Shared pointer to the logical expression. \\
\hline
{\em assignments\+\_\+map} & Reference to an unordered map of variable assignments. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Shared pointer to the modified logical expression. 
\end{DoxyReturn}
